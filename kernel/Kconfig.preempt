# SPDX-License-Identifier: GPL-2.0-only

config HAVE_PREEMPT_LAZY
	bool

config PREEMPT_LAZY
	def_bool y if HAVE_PREEMPT_LAZY && PREEMPT_RT

choice
	prompt "Preemption Model"
	default PREEMPT_NONE

config PREEMPT_NONE
	bool "No Forced Preemption (Server)"
	help
	  This is the traditional Linux preemption model, geared towards
	  throughput. It will still provide good latencies most of the
	  time, but there are no guarantees and occasional longer delays
	  are possible.

	  Select this option if you are building a kernel for a server or
	  scientific/computation system, or if you want to maximize the
	  raw processing power of the kernel, irrespective of scheduling
	  latencies.

config PREEMPT_VOLUNTARY
	bool "Voluntary Kernel Preemption (Desktop)"
	depends on !ARCH_NO_PREEMPT
	help
	  This option reduces the latency of the kernel by adding more
	  "explicit preemption points" to the kernel code. These new
	  preemption points have been selected to reduce the maximum
	  latency of rescheduling, providing faster application reactions,
	  at the cost of slightly lower throughput.

	  This allows reaction to interactive events by allowing a
	  low priority process to voluntarily preempt itself even if it
	  is in kernel mode executing a system call. This allows
	  applications to run more 'smoothly' even when the system is
	  under load.

	  Select this if you are building a kernel for a desktop system.

config PREEMPT
	bool "Preemptible Kernel (Low-Latency Desktop)"
	depends on !ARCH_NO_PREEMPT
	select PREEMPTION
	select UNINLINE_SPIN_UNLOCK if !ARCH_INLINE_SPIN_UNLOCK
	help
	  This option reduces the latency of the kernel by making
	  all kernel code (that is not executing in a critical section)
	  preemptible.  This allows reaction to interactive events by
	  permitting a low priority process to be preempted involuntarily
	  even if it is in kernel mode executing a system call and would
	  otherwise not be about to reach a natural preemption point.
	  This allows applications to run more 'smoothly' even when the
	  system is under load, at the cost of slightly lower throughput
	  and a slight runtime overhead to kernel code.

	  Select this if you are building a kernel for a desktop or
	  embedded system with latency requirements in the milliseconds
	  range.

config PREEMPT_RT
	bool "Fully Preemptible Kernel (Real-Time)"
	depends on EXPERT && ARCH_SUPPORTS_RT
	select PREEMPTION
	help
	  This option turns the kernel into a real-time kernel by replacing
	  various locking primitives (spinlocks, rwlocks, etc.) with
	  preemptible priority-inheritance aware variants, enforcing
	  interrupt threading and introducing mechanisms to break up long
	  non-preemptible sections. This makes the kernel, except for very
	  low level and critical code pathes (entry code, scheduler, low
	  level interrupt handling) fully preemptible and brings most
	  execution contexts under scheduler control.
 
	  Select this if you are building a kernel for systems which
	  require real-time guarantees.
 
endchoice

config MCST_RT
	bool "MCST enhancement of PREEMPT_RT"
	default y
	depends on MCST && PREEMPT_RT
	help
	   Possibility to turn off some fair opportunuties
	   for all tasks to decrease latency for RT tasks

config USB_IRQ_ON_THREAD
	bool "USB irq implemented as threaded irq "
	depends on MCST_RT
	default y
	help
	  USB interrupt handler just find out interrupt, all other work
	  is done on threadfn thread. It is useful if USB shares irq with
	  important rt device.
	  Say Y if you want that usb interrupts executed on kernel thread.
	  Otherwise say N

config MCST_RT_SMP
        bool
        depends on SMP

config MCST_RT_GRQ
        bool "MCST RT: Global Runqueue Additions"
        depends on  MCST_RT && SMP
        default y
        select MCST_RT_SMP

config MCST_RT_NUMA
        bool "MCST RT NUMA additions"
        depends on  MCST_RT && NUMA && !GROUP_SCHED && !CPUSETS
        default y
        select MCST_RT_SMP

config NETDEV_THREADS
	bool "Each net dev has personal softirq threads"
	depends on MCST_RT
	default n
	help
	  net devices don't use SOFTIRQ stuff (NET_TX_SOFTIRQ and
	  NET_RX_SOFTIRQ not used). Each net device has it's own
	  threads pair - one for receiving and one for transmitting. It's
	  possible to bind these threads to CPU and assign priority
	  for each thread separately.

config PREEMPT_COUNT
       bool

config PREEMPTION
       bool
       select PREEMPT_COUNT
