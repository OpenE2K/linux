	Поддержка файловой системы proc в компиляторе приложений.

	Файловая система proc предоставляет из один интерфейсов взаимодействия с ядром ОС и
широко используется в пользовательских приложениях. Бинарный компилятор берет на себя
часть функций ОС и, как следствие, информация, предоставляемая procfs, может оказаться
не корректной с точки зрения транслируемого приложения. К файлам, требующим коррекции
относятся:
 -# /proc/auxv - информация интерпретатора ELF (вспомогательный вектрор)
 -# /proc/pid/maps, /proc/pid/smaps - карта памяти процесса
 -# /proc/pid/cmdline - строка запуска процесса
 -# /proc/pid/limits - информация о resource limits
 -# /proc/pid/exe - ссылка на исполняемый файл приложения
 -# /proc/pid/mounts, mountinfo, mountstats, - информация о примонтированных fs


	Обработка и подмена этой информации на уровне компилятора приложений осложнена тем,
что доступ к файлам в procfs может осущеставляться через ссылки или открытые перед
execve() файловые дескрипторы: нет простого и надежного способа понять, что обращение
идёт к интересующему нас файлу. Кроме того, являясь виртуальной файловой системой, proc
предоставляет особенные методы работы с некоторыми файлами.
	Для решения этой проблемы была реализована собственная файловая система rtc_proc в
виде модуля ядра linux. Новая файловая система должна прозрачно монтироваться для
транслируемого приложения вместо настоящего proc. Таким образом задача отслеживания
обращений к procfs снимается с компилятора приложений.

    	Устройство модуля rtc_proc.
	Файлы в procfs формируются динамически и меняются в процессе работы приложений, а
методы их формирования являются частью ядра и могут зависеть от версии. При обращении
к файлу, не нуждающемуся в обработке, необходимо показать его "как есть". Для этого
в модуле выполняется монтирование fc_mount() настоящей procfs, и, если файл нас не
интересует, работа с ним производится с помощью методов оригинальной procfs. В случае,
если файл нуждается в обработке, аллоцируются новые объекты файловой системы rtc_proc
(dentry и inode) с подменёнными функциями для отображения нужного содержимого. Информация
в procfs зависит от значения pid namespace на момент монтирования, поэтому монтировать
экземпляр proc нужно при каждом заполнении суперблока.

Состав модуля:
 -#	root.c 	  - инициализация работы модуля
 -#	rtcproc.c - функционал файловой системы
 -#	files.c   - обработка специальных файлов

1. Начало работы
	При загрузке модуля, функция rtcfs_init() выполняет инициализацию кэша inode'ов,
поиск некоторых неэкспортированных символов ядра и регистрацию файловой системы.
    Кэш inode хранит в себе объекты rtc_proc, которые представляют собой сам inode и
структуру path для однозначной связи объектов в rtc_proc и proc.
При монтировании файловой системы, происходит формирование суперблока (если он не был
найден) в функции rtcfs_fill_super(). Там же происходит выделение памяти для приватной
информации (sb->s_fs_info). Она хранит:
 -#	указатель на структуру pid_namespace, для которой формируется суперблок;
 -#	указатель на структуру vfsmount для примонтированного proc;
 -#	битовое поле options для поддержки опций procfs.
    Корень rtc_proc (поле sb->s_root), как и остальные объекты, имеет связь с аналогичным
объектом в proc. Функция vfs_path_lookup() возвращает структуру path для корня с
увеличенным refcounter, обозначая использование этого объекта в procfs. Функция
rtcfs_duplicate_proc_inode() аллоцирует inode в rtcfs, копируя атрибуты оригинального
объекта, включая номер inode.

2. Чтение директорий, поиск объектов
    При заполнении суперблока, inod'y корня файловой системы назначаются структуры
file_operations и inode_operations, определяющие функции чтения и нахождения объектов в
данной директории. Так как содержимое нашей файловой системы должно быть идентично proc,
функция rtcfs_readdir() получает inode оригинального объекта, преобразует структуру file
для соответствия procfs и передаёт запрос оригинальному методу.
    Функция поиска объекта возвращает указатель на объект в виде структуры dentry. Работа
(открытие, чтение и т.д.) с dentry ведется без участия файловой системы, поэтому
определение необходимости подмены объекта для корня определяется в функции
rtcfs_root_lookup(). Объекты, не нуждающиеся в изменении, можно было бы отдавать как есть.
Однако, в ядре могут присутствовать проверки, вызывающие панику ядра при работе с "чужим"
объектом для данной файловой системы. Пока что такая ситуация была обнаружена только при
работе с файлами, поэтому для них происходит аллокация dentry, ссылающуюся на объект из
proc (функция rtcfs_allocacte_dentry_for_inode()).

3. Работа с методами и dentry cache
    Для объекта, нуждающегося в изменении, аллоцируется dentry и inode в rtc_proc с
подменой интересующих нас методов. Для корня такими объектами являются директории <pid>
компилятора приложений (нужно переопределить метод lookup для возможности выдачи
поддельных объектов, а в директории pid нужно переопределить lookup для task и т.д. пока
не дойдём до искомого объекта). Основная функция, определяющая необходимость коррекции
файла - rtcfs_pid_tid_lookup() - одинакова для директори pid и pid/task/tid.
    Методы rtcfs_*_lookup пытаются найти объект в файловой системе proc с помощью функции
vfs_path_lookup(). Если объект был найден, структура path подвязывается к объекту в rtcfs
для возможности вызова оригинальных методов объекта. Неинтересующие нас методы, такие как
getattr, реализованы через вызов метода для оригинального inode в proc. Получение
структуры path так же означает, что объет не будет удалён из proc. Для разрыва связи с
proc при уничтожении rtcfs inode вызывается path_put().
    Уничтожение inode происходит тогда, когда не остаётся ни одной указывающей на него
dentry. В зависимости от того, что вернет метод d_delete, при прекращении работы с dentry
она может оставаться в кэше, либо быть удалена. Для поддержания соответствия с реальным
proc, в текущей реализации кэш dentry отключен. Таким образом, при каждом новом обращении
к объекту происходит обращение к proc.

4. Обработка специальных файлов
    Функции формирования и отображения файлов являются частью ядра и не экспопртированы.
Так же есть шанс, что в новой версии ядра они могу поменяться, поэтому нет возможности
работать с ними напрямую или скопировать целиком. Тем не менее, есть доступ к
оригинальным inode и их структурам содержащим указатели на эти функции.
    Для файлов, работающих через seq_file (maps, smaps, mounts, mountinfo, mountstats),
открытие и закрытие происходят через rtcfs_seqfile_open_common() и
rtcfs_seqfile_release(). rtcfs_seqfile_open_common() сначала вызывает оригинальную
функцию, которая аллоцирует память и заполняет приватные данные структуры file (в т.ч.
указатели на функции для работы с seq_file). Затем указатели на оригинальные функции
сохраняются, а функция .show подменяется. Функция .show отвечает за отображение
сформированных данных. В подменной функции формируется промежуточный буффер, который
передаётся в оригинальную show(), и который правится перед его копированием пользователю.
    Файл limits также работает с seq_file, но для него proc использует *single* функции.
single_open() динамически выделяет память для структуры struct seq_operations, а
single_close() освобождает память. Это необходимо учитывать при подмене функций.
    Для файла cmdline функция .read сразу сохраняет прочитанные данные в буффер в
адресном пространстве пользователя, поэтому в подменной функции реализован весь
функционал оригинальной функции.
    Для файла exe понадобилась специальная поддержка в ядре. Так как в ядре нет единого
корня, пути хранятся в виде специальных структур path. Это позволяет разрешать
путь вне зависимости от текущего корня, но порождает проблему нахождения файла по
символьному пути. В произвольный момент времени найти файл (inode) по абсолютному
пути нельзя - корень мог быть изменен.
    Оригинальный exe_path хранится в mm_struct и соответствующим образом обрабатывается
при execve() или завершении процесса, поэтому просто формирования path недостаточно:
кто-то должен вызывать функции освобождения структур при внезапной смерти процесса.
    В ядро была добавлена возможность передачи и хранения информации для бинарного
компилятора через системный вызов el_binary() (bug 140705). Так как передачи символьного
пути недостаточно, бинарный компилятор передаёт адрес, по которому замапирован x86 файл.
По этому адресу в подменной функции можно найти vm_area_struct, содержащую path.
Для случая, когда не удаётся найти vma или path, поиск файла ищется функцией
vfs_path_lookup() в предположении, что это первый запуск, и адрес vma ещё не успели
установить.
